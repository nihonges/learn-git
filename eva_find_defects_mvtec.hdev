<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="25.05.0.0">
<procedure name="main">
<interface/>
<body>
<c>*****************************************************************</c>
<c>*</c>
<c>* Evaluation</c>
<c>*</c>
<c>*****************************************************************</c>
<c>*</c>
<c>*****************************************************************</c>
<c>* Parameter</c>
<c>*****************************************************************</c>
<l>* PathImages := 'C:/Arbeit/Pool/Machbarkeitsstudie Glasplatten/results/'</l>
<l>PathImages := './'</l>
<c>*</c>
<c>* GPU</c>
<l>DeviceVendorToUse := 'NVIDIA Corporation'</l>
<l>DeviceNameToUse := 'NVIDIA GeForce RTX 5060 Ti'</l>
<c>*</c>
<c>* Thresholds</c>
<l>Graythre := 50</l>
<l>MinDefectArea := 20</l>
<l>MaxDefectArea := 99</l>
<c></c>
<l>MinDefectRatio := 0.85</l>
<l>MaxDefectRatio := 1.4</l>
<c>* 055-0.7</c>
<l>MinDefectRoundness := 0.55</l>
<l>MaxDefectRoundness := 1</l>
<l>MinDefectCompactness := 1</l>
<l>MaxDefectCompactness := 1.4</l>
<c>*****************************************************************</c>
<c>* Initialization</c>
<c>*****************************************************************</c>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Initialization of the files</c>
<l>list_image_files (PathImages, 'default', [], ImageFiles)</l>
<c>*</c>
<c>* Initialization of the display window</c>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 512, 512, 'black', WindowHandle)</l>
<c>*</c>
<c>* Initialization of further display parameters</c>
<l>set_display_font (WindowHandle, 16, 'mono', 'true', 'false')</l>
<l>dev_set_colored (12)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<c>*</c>
<c>* Initialization of the DeviceHandle</c>
<l>DeviceHandle := []</l>
<l>query_available_compute_devices (DeviceIdentifiers)</l>
<l>for Index := 0 to |DeviceIdentifiers|-1 by 1</l>
<l>    get_compute_device_info (DeviceIdentifiers[Index], 'name', DeviceName)</l>
<l>    get_compute_device_info (DeviceIdentifiers[Index], 'vendor', DeviceVendor)</l>
<l>    if (DeviceVendor == DeviceVendorToUse and \
        DeviceName == DeviceNameToUse)</l>
<l>        open_compute_device (DeviceIdentifiers[Index], DeviceHandle)</l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<c>*</c>
<l>if (DeviceHandle != [])</l>
<l>    init_compute_device (DeviceHandle, 'mean_image')</l>
<l>endif</l>
<c>*****************************************************************</c>
<c>* Application</c>
<c>*****************************************************************</c>
<c>* Work through sample folder</c>
<l>for I := 0 to (|ImageFiles|)-1 by 1</l>
<l>    count_seconds (T1)</l>
<l>    read_image (Image, ImageFiles[I])</l>
<c>    * Save the mask of the coordinate of defects</c>
<l>    get_image_size (Image, ImgWidth, ImgHeight)</l>
<l>    gen_image_const(EmptyImage, 'byte', ImgWidth, ImgHeight)</l>
<l>    invert_image (EmptyImage, EmptyImage)</l>
<c></c>
<l>    FileName := ImageFiles[I]</l>
<l>    tuple_strstr( FileName, '300dpi', Position300)</l>
<l>    tuple_strstr( FileName, '600dpi', Position600)</l>
<c>    * Different thresholds for 300dpi/600dpi</c>
<c>    * 24598x29998 600dpi</c>
<l>    if ( Position600 &gt;= 0)</l>
<l>        Graythre := 50</l>
<l>        MinDefectArea := 20</l>
<l>        MaxDefectArea := 99</l>
<c>        </c>
<l>        MinDefectRatio := 0.85</l>
<l>        MaxDefectRatio := 1.4</l>
<c>        * 055-0.7</c>
<l>        MinDefectRoundness := 0.55</l>
<l>        MaxDefectRoundness := 1</l>
<l>        MinDefectCompactness := 1</l>
<l>        MaxDefectCompactness := 1.4  </l>
<l>    endif</l>
<c>    * 10800x15000 300dpi</c>
<l>    if ( Position300 &gt;= 0)</l>
<l>        Graythre := 40</l>
<l>        MinDefectArea := 5</l>
<l>        MaxDefectArea := 50</l>
<l>        MinDefectRatio := 0.55</l>
<l>        MaxDefectRatio := 1.4</l>
<l>        MinDefectRoundness := 0.15</l>
<l>        MaxDefectRoundness := 1</l>
<l>        MinDefectCompactness := 1</l>
<l>        MaxDefectCompactness := 1.4</l>
<l>    endif</l>
<c>    *</c>
<c>    * Color information is not necessary</c>
<l>*     rgb1_to_gray (Image, GrayImage)</l>
<l>    rgb1_to_gray (Image, GrayImage)</l>
<c>    *</c>
<c>    * Remove boundary from domain</c>
<l>    threshold (GrayImage, Region, 255, 255)</l>
<l>    fill_up (Region, Foreground)</l>
<l>    reduce_domain (GrayImage, Foreground, ImageReduced)</l>
<c>    *</c>
<l>    if (DeviceHandle != [])</l>
<c>        * Mean image on a compute device</c>
<l>        activate_compute_device (DeviceHandle)</l>
<l>        mean_image (ImageReduced, ImageMeanBubble, 51, 51)</l>
<c>        *</c>
<c>        * Mean image on the CPU</c>
<l>*         deactivate_compute_device (DeviceHandle)</l>
<l>*         mean_image (ImageReduced, ImageMeanBubble, 51, 51)</l>
<l>    else</l>
<l>        mean_image (ImageReduced, ImageMeanBubble, 51, 51)</l>
<l>    endif</l>
<c>    *</c>
<c>    * Detection of the defects</c>
<l>*     mean_image (ImageReduced, ImageMeanBubble, 51, 51)</l>
<l>    dyn_threshold (ImageReduced, ImageMeanBubble, RegionDynThreshContamination, Graythre, 'dark')</l>
<l>    connection (RegionDynThreshContamination, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, Defects, ['area', 'ratio', 'roundness', 'holes_num', 'compactness'], 'and', [MinDefectArea, MinDefectRatio, MinDefectRoundness, 0.9, MinDefectCompactness], [MaxDefectArea, MaxDefectRatio, MaxDefectRoundness, 1.1,MaxDefectCompactness])</l>
<c>    *</c>
<c>    * Display potential defect regions</c>
<l>    gen_contour_region_xld (Defects, Contours, 'border')</l>
<l>    fit_circle_contour_xld (Contours, 'atukey', -1, 2, 0, 5, 2, RowC, ColumnC, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>    gen_circle_contour_xld (ContCircleBlock, RowC, ColumnC, Radius+30, 0, 6.28318, 'positive', 1)</l>
<c>    *</c>
<c>    *</c>
<l>    gen_region_contour_xld(ContCircleBlock, CircleRegion, 'filled')</l>
<l>    union1(CircleRegion, MergedCircles)</l>
<l>    paint_region (MergedCircles, EmptyImage, ImageResult, 0, 'fill')</l>
<c>    </c>
<l>    tuple_split(FileName, '/', path_parts)</l>
<l>    tuple_split(path_parts, '.', name_parts)</l>
<l>    fileName := name_parts[0]</l>
<l>    name_only := name_parts[0]</l>
<l>    tuple_regexp_replace(FileName, '^.*/', '', name_only)</l>
<l>    new_filename := './results/' + fileName + '_results.jpg'</l>
<l>    write_image(ImageResult, 'jpeg', 0, new_filename)</l>
<c>    </c>
<l>*     dev_display (ImageReduced)</l>
<l>*     dev_display (ContCircleBlock)</l>
<c>    * Classify if the object is defect or not</c>
<l>    count_seconds (T2)</l>
<l>    Times := (T2 - T1)</l>
<l>    count_obj (Defects, NumberOfDefects)</l>
<l>    if (NumberOfDefects &gt; 0)</l>
<l>        Text := FileName + '\n' + 'NG: ' + NumberOfDefects + ' defects are detected!' + '  Time: ' + Times + 's'</l>
<l>        Color := 'red'</l>
<l>    else</l>
<l>        Text := FileName + '\n' + 'OK: No defects are detected!' + '  Time: ' + Times + 's'</l>
<l>        Color := 'forest green'</l>
<l>    endif</l>
<c>    *</c>
<c>    * Display of results</c>
<l>    dev_display (Image)</l>
<l>    dev_display (Defects)</l>
<l>    dev_display (ContCircleBlock)</l>
<c></c>
<l>    dev_disp_text (Text, 'window', 'top', 'left', Color, [], [])</l>
<c>    *</c>
<l>    dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c></c>
<l>    stop ()</l>
<l>endfor</l>
<l>stop ()</l>
<c>*</c>
<c>*****************************************************************</c>
<c>* Clean up</c>
<c>*****************************************************************</c>
<l>dev_clear_window ()</l>
<l>dev_update_on ()</l>
<l>dev_disp_text ('End of program', 'window', 'top', 'left', 'black', [], [])</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
